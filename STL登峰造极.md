# S登封造极

## STL基础

### STL是什么，有什么用？

STL，英文全称 standard template library，==中文可译为标准模板库或者泛型库==，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。

STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。值得一提的是，如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装，这可能也是 STL 被广泛使用的原因之一。

> STL 就位于各个 C++ 的头文件中，即它并非以二进制代码的形式提供，而是以源代码的形式提供。

从根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和数据结构的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。

> 注意，这里提到的==容器，本质上就是封装有数据结构的模板类==，例如 list、vector、set、map 等，有关这些容器的具体用法，后续章节会做详细介绍。

### STL的优势在哪里？

在 C++ 中如果定义一个数组，可以采用如下方式：

`int a[n];`

这种定义数组的方法需要事先确定好数组的长度，即 n 必须为常量，这意味着，如果在实际应用中无法确定数组长度，则一般会将数组长度设为可能的最大值，但这极有可能导致存储空间的浪费。

所以除此之外，还可以采用在堆空间中动态申请内存的方法，此时长度可以是变量：

`int *p = new int[n];`

这种定义方式可根据变量 n 动态申请内存，不会出现存储空间浪费的问题。但是，如果程序执行过程中出现空间不足的情况时，则需要加大存储空间，此时需要进行如下操作：

1. 新申请一个较大的内存空间，即执行`int * temp = new int[m];`
2. 将原内存空间的数据全部复制到新申请的内存空间中，即执行`memecpy(temp, p, sizeof(int)*n);`
3. 将原来的堆空间释放，即执行`delete [] p; p = temp;`

而完成相同的操作，如果采用 STL 标准库，则会简单很多，因为大多数操作细节将不需要程序员关心。下面是使用向量模板类 vector 实现以上功能的示例：

```cpp
vector <int> a; //定义 a 数组，当前数组长度为 0，但和普通数组不同的是，此数组 a 可以根据存储数据的数量自动变长。
//向数组 a 中添加 10 个元素
for (int i = 0; i < 10 ; i++)
    a.push_back(i)
//还可以手动调整数组 a 的大小
a.resize(100);
a[90] = 100;
//还可以直接删除数组 a 中所有的元素，此时 a 的长度变为 0
a.clear();
//重新调整 a 的大小为 20，并存储 20 个 -1 元素。
a.resize(20, -1)
```

对比以上两种使用数组的方式不难看出，使用 STL 可以更加方便灵活地处理数据。所以，大家只需要系统地学习 STL，便可以集中精力去实现程序的功能，而无需再纠结某些细节如何用代码实现。



==一句话，所有的数据结构建立的所有用意就是对元素增查删改，而STL可以利用包装化的接口极大程度的方便这一点，让我们可以更加专注于算法的实现，而不需要去关注内存占用情况等等~~没用的东西~~...==

——所以话说回来，这些东西python的前辈们早就开发好了，到底为什么不用python呢？

### 

## STL容器

### STL容器是什么？

在实际的开发过程中，合理组织数据的存取与选择处理数据的算法同等重要，存取数据的方式往往会直接影响到对它们进行增删改查操作的复杂程度和时间消耗。事实上，当程序中存在对时耗要求很高的部分时，数据结构的选择就显得尤为重要，有时甚至直接影响程序执行的成败。

值得一提的是，之前我们一直在不断地重复实现一些诸如链表、集合等等这些常见的数据结构，这些代码使用起来往往都十分类似，只是为了适应不同数据的变化，可能需要在一些细节上做不同的处理。

那么大家有没有想过，是不是可以重复利用那些已有的实现来完成当前的任务呢？当然是可行的，有些读者已经亲自编写并实现了动态数组类、链表类、集合类等程序，并精心维护着。其实，STL中提供了专家级的几乎我们所需要的各种容器，功能更好，复用性更高。

==简单的理解容器，它就是一些模板类的集合，但和普通模板类不同的是，容器中封装的是组织数据的方法（也就是数据结构）。==STL 提供有 3 类标准容器，分别是序列容器、排序容器和哈希容器，其中后两类容器有时也统称为关联容器。它们各自的含义如下表所示。

| **容器种类** | **功能**                                                     |
| ------------ | :----------------------------------------------------------- |
| 序列容器     | 主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即==容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。== |
| 排序容器     | 包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。==所以关联容器在查找时具有非常好的性能。== |
| 哈希容器     | c++ 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，==哈希容器中的元素是未排序的，元素的位置由哈希函数确定。== |

> 注意，由于哈希容器直到 C++ 11 才被正式纳入 C++ 标准程序库，而在此之前，“民间”流传着 hash_set、hash_multiset、hash_map、hash_multimap 版本，不过该版本只能在某些支持 C++ 11 的编译器下使用（如 VS），有些编译器（如 gcc/g++）是不支持的。

以上 3 类容器的存储方式完全不同，因此使用不同容器完成相同操作的效率也大不相同。所以在实际使用时，要善于根据想实现的功能，选择合适的容器。

### STL序列式容器

所谓序列容器，即以线性排列（类似普通数组的存储方式）来存储某一指定类型（例如 int、double 等）的数据，需要特殊说明的是，该类容器并不会自动对存储的元素按照值的大小进行排序。

需要注意的是，序列容器只是一类容器的统称，并不指具体的某个容器，序列容器大致包含以下几类容器：

- ##### array<T,N>（数组容器）：表示可以存储 N 个 T 类型的元素，是 C++ 本身提供的一种容器。此类容器一旦建立，==其长度就是固定不变的==，这意味着不能增加或删除元素，只能改变某个元素的值；

- ##### vector<T>（向量容器）：用来存放 T 类型的元素，==是一个长度可变的序列容器==，即在存储空间不足时，会自动申请更多的内存。使用此容器，在==尾部==增加或删除元素的效率最高（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）；

- ##### deque<T>（双端队列容器）：和 vector 非常相似，区别在于使用该容器==不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效==，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；

- ##### list<T>（链表容器）：是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，==在这个序列的任何地方都可以高效地增加或删除元素==（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list<T> 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。

- ##### forward_list<T>（正向链表容器）：和 list 容器非常类似，只不过它以单链表的形式组织元素，==它内部的元素只能从第一个元素开始访问==，是一类比链表容器快、更节省内存的容器。

> 注意，其实除此之外，stack<T> 和 queue<T> 本质上也属于序列容器，只不过它们都是在 deque 容器的基础上改头换面而成，通常更习惯称它们为容器适配器，有关它们的介绍，会放到后续章节中。

#### array

#### vector(向量容器)

##### 简介

vector 容器是 STL中最常用的容器之一，它和 array 容器非常类似，都可以看做是对普通数组的“升级版”。不同之处在于，==array 实现的是静态数组（容量固定的数组）==，而 ==vector 实现的是一个动态数组，即可以进行元素的插入和删除==，在此过程中，vector 会动态调整所占用的内存空间，整个过程无需人工干预。

vector 常被称为向量容器，因为==该容器擅长在尾部插入或删除元素，在常量时间内就可以完成==，时间复杂度为`O(1)`；而对于在容器头部或者中部插入或删除元素，则花费时间要长一些（移动元素需要耗费时间），时间复杂度为线性阶`O(n)`。

vector 容器以类模板 vector<T>（ T 表示存储元素的类型）的形式定义在 <vector> 头文件中，并位于 std 命名空间中。因此，在创建该容器之前，代码中需包含如下内容：

```cpp
#include <vector>
using namespace std;
```

> 注意，std 命名空间也可以在使用 vector 容器时额外注明，两种方式都可以。

##### 创建容器

1. 直接使用 ==数据结构类型<数据类型> 结构名字==来创建

   例如：

   ```cpp
   std::vector<double> values;
   ```

   注意，这是一个空的 vector 容器，因为容器中没有元素，所以没有为其分配空间。当添加第一个元素（比如使用 push_back() 函数）时，vector 会自动分配内存。

2. 和其他容器一样，可以在创建的同时指定初始值以及元素个数，比如：

   ```cpp
   std::vector<int> primes {2, 3, 5, 7, 11, 13, 17, 19};
   ```

   这样就创建了一个含有 8 个素数的 vector 容器。

3. 在创建 vector 容器时，也可以仅指定元素个数：

   ```cpp
   std::vector<double> values(20,1.0);
   ```

   > 注意，圆括号 () 和大括号 {} 是有区别的，前者（例如 (20) ）表示元素的个数，而后者（例如 {20} ） 则表示 vector 容器中只有一个元素 20。

   第二个参数指定了所有元素的初始值，因此这 20 个元素的值都是 1.0。

   第二个形参的初始值为0，因此直接不填就可以把值初始化为0，达到数组初始化的效果。

##### 增

要知道，向 vector 容器中添加元素的唯一方式就是使用它的成员函数，如果不调用成员函数，非成员函数既不能添加也不能删除元素。这意味着，vector 容器对象必须通过它所允许的函数去访问，迭代器显然不行。

###### push_back() 尾部添加

该成员函数的功能是在 vector 容器尾部添加一个元素，用法也非常简单，比如：

```cpp
#include <iostream>
#include <vector>
using namespace std;//以后这些头文件，命名空间和主函数之类的东西就省略啦，用来给大家更加清晰的展现代码逻辑。
int main()
{
    vector<int> values{};
    values.push_back(1);//从末尾增加一个元素1
    values.push_back(2);//从末尾增加一个元素2
    for (int i = 0; i < values.size(); i++) {
        cout << values[i] << " ";//输出元素
    }
    return 0;
}
```

输出后的结果如下所示：

```
1 2
```

这个非常直观 没啥好讲的

###### emplace_back() 尾部添加

该函数是 C++ 11 新增加的，其功能和 push_back() 相同，都是在 vector 容器的尾部添加一个元素。

其用法也很简单，这里直接举个例子：

```cpp
vector<int> values{};
values.emplace_back(1);
values.emplace_back(2);
for (int i = 0; i < values.size(); i++)
{
	cout << values[i] << " ";
}
```

运行结果为：

```
`1 2`
```

以上 2 段代码，只是用 emplace_back() 替换了 push_back()，既然它们实现的功能是一样的，那么 C++ 11 标准中为什么要多此一举呢？

###### emplace_back()和push_back()的区别

emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。

==一句话，完成同样的操作，push_back() 的底层实现过程比 emplace_back() 更繁琐，换句话说，emplace_back() 的执行效率比 push_back() 高。因此，在实际使用时，建议大家优先选用 emplace_back()。==

###### insert() 中间插入

insert() 函数的功能是在 vector 容器的指定位置插入一个或多个元素，用法说明如下：

| 语法格式                        | 用法说明                                                     |
| ------------------------------- | ------------------------------------------------------------ |
| iterator insert(pos,elem)       | 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。 |
| iterator insert(pos,n,elem)     | 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。 |
| iterator insert(pos,first,last) | 在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。 |
| iterator insert(pos,initlist)   | 在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。 |

例如：

```cpp
std::vector<int> demo{1,2};
//第一种格式用法
demo.insert(demo.begin() + 1, 3);//{1,3,2}

//第二种格式用法
demo.insert(demo.end(), 2, 5);//{1,3,2,5,5}

//第三种格式用法
std::array<int,3>test{ 7,8,9 };
demo.insert(demo.end(), test.begin(), test.end());//{1,3,2,5,5,7,8,9}

//第四种格式用法
demo.insert(demo.end(), { 10,11 });//{1,3,2,5,5,7,8,9,10,11}

for (int i = 0; i < demo.size(); i++) {
    cout << demo[i] << " ";
}
```

输出结果为：

```cpp
1 3 2 5 5 7 8 9 10 11
```



###### emplace() 中间插入

emplace() 是 C++11 标准新增加的成员函数，用于在 vector 容器指定位置之前插入一个新的元素。

> 再次强调，emplace() 每次只能插入一个元素，而不是多个。

该函数的语法格式如下：

```cpp
iterator.emplace (const_iterator pos, args...);//iterator是vector的名字噢
```

其中，pos 为指定插入位置的迭代器；args... 表示与新插入元素的构造函数相对应的多个参数；该函数会返回表示新插入元素位置的迭代器。

> 简单的理解 args...，即被插入元素的构造函数需要多少个参数，那么在 emplace() 的第一个参数的后面，就需要传入相应数量的参数。

举个例子：

```cpp
std::vector<int> demo1{1,2};
//emplace() 每次只能插入一个 int 类型元素
demo1.emplace(demo1.begin(), 3);
for (int i = 0; i < demo1.size(); i++) {
cout << demo1[i] << " ";
}
```

运行结果为：

```cpp
3 1 2
```

###### insert()和emplace()的区别

既然 emplace() 和 insert() 都能完成向 vector 容器中插入新元素，那么谁的运行效率更高呢？答案是 emplace()。

原因是：通过 insert() 函数向 vector 容器中插入 testDemo 类对象，需要调用类的构造函数和移动构造函数（或拷贝构造函数）；而通过 emplace() 函数实现同样的功能，只需要调用构造函数即可。

==一句话，emplace() 在插入元素时，是在容器的指定位置直接构造元素，而不是先单独生成，再将其复制（或移动）到容器中。因此，在实际使用中，推荐大家优先使用 emplace()。==



## STL迭代器

